<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ê±âÂ≠óÊèèÊëπÊùø (Hanzi Tracing Pad)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        html, body { height: 100%; overflow: hidden; margin: 0; padding: 0; font-family: 'Inter', 'Noto Sans SC', sans-serif; background-color: #f0f9ff; }
        body { display: flex; flex-direction: column; }
        .layout-container { display: flex; flex-grow: 1; overflow: hidden; width: 100%; }

        /* TOC Sidebar */
        #tocContainer { width: 100px; flex-shrink: 0; height: 100%; overflow-y: auto; background-color: #e0f2fe; border-right: 2px solid #bae6fd; padding: 0.5rem; }
        .toc-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(40px, 1fr)); gap: 0.5rem; }
        .toc-item { font-family: 'Noto Sans SC', sans-serif; font-size: 1.8rem; padding: 0.3rem; text-align: center; cursor: pointer; border-radius: 0.375rem; background-color: #ffffff; transition: background-color 0.2s ease; user-select: none; border: 1px solid #d1d5db; }
        .toc-item:hover { background-color: #bfdbfe; }
        .toc-item.active { background-color: #3b82f6; color: white; font-weight: bold; border-color: #2563eb; }

        /* Main Content Area */
        #mainContentArea { flex-grow: 1; display: flex; flex-direction: column; align-items: center; padding: 1rem; height: 100%; overflow-y: auto; background-color: #f0f9ff; /* Á°Æ‰øùÂÜÖÂÆπÂå∫‰πüÊúâËÉåÊôØËâ≤ */ }

        /* Character Display */
        .character-display { font-family: 'Noto Sans SC', sans-serif; font-size: 15rem; line-height: 1; color: #d1d5db; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); user-select: none; z-index: 1; }
        #drawingCanvas { position: absolute; top: 0; left: 0; cursor: crosshair; z-index: 10; touch-action: none; }

        /* Buttons */
        .control-button { padding: 0.8rem 1.5rem; font-size: 1.2rem; font-weight: bold; color: white; background-color: #3b82f6; border: none; border-radius: 0.75rem; cursor: pointer; transition: background-color 0.3s ease, opacity 0.3s ease; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .control-button:hover:not(:disabled) { background-color: #2563eb; }
        .control-button:active:not(:disabled) { background-color: #1d4ed8; transform: translateY(1px); }
        .control-button:disabled { background-color: #9ca3af; opacity: 0.7; cursor: not-allowed; }

        #fullscreenBtn { background-color: #10b981; }
        #fullscreenBtn:hover:not(:disabled) { background-color: #059669; }
        #fullscreenBtn:active:not(:disabled) { background-color: #047857; }
        #prevBtn { background-color: #f59e0b; }
        #prevBtn:hover:not(:disabled) { background-color: #d97706; }
        #prevBtn:active:not(:disabled) { background-color: #b45309; }


        /* Drawing Area Container */
        .main-container { position: relative; width: 100%; height: 55vh; max-width: 550px; margin: 0 auto 1rem auto; border: 2px solid #e5e7eb; border-radius: 0.75rem; overflow: hidden; background-color: white; box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1); flex-shrink: 0; }

        /* Meaning/Emoji Container */
        .meaning-container { display: flex; justify-content: center; align-items: center; margin-top: 1rem; min-height: 80px; flex-shrink: 0; }
        #meaningEmoji { font-size: 4rem; line-height: 1; }

        /* Controls Container */
        .controls-container { display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 1rem; margin-top: 1rem; padding: 0 1rem; width: 100%; flex-shrink: 0; }
        .checkbox-container { display: flex; align-items: center; gap: 0.5rem; font-size: 1.1rem; color: #1f2937; }
        #randomCheckbox { width: 1.2rem; height: 1.2rem; cursor: pointer; }

        /* Page Title */
        #pageTitle { text-align: center; padding: 0.5rem 0; font-size: 1.8rem; font-weight: bold; color: #1d4ed8; width: 100%; flex-shrink: 0; }
    </style>
</head>
<body>

    <h1 id="pageTitle">Ê±âÂ≠óÊèèÊëπÊùø</h1>

    <div class="layout-container">
        <div id="tocContainer">
            <div id="tocList" class="toc-list">
                </div>
        </div>

        <div id="mainContentArea">
            <div id="canvasContainer" class="main-container">
                <div id="characterDisplay" class="character-display"></div>
                <canvas id="drawingCanvas"></canvas>
            </div>

            <div class="meaning-container">
                <span id="meaningEmoji" aria-hidden="true"></span> </div>

            <div class="controls-container">
                <button id="clearBtn" class="control-button">Ê∏ÖÈô§ (Clear)</button>
                <button id="prevBtn" class="control-button">‰∏ä‰∏Ä‰∏™ (Prev)</button>
                <button id="nextBtn" class="control-button">‰∏ã‰∏Ä‰∏™ (Next)</button>
                <button id="fullscreenBtn" class="control-button">ÂÖ®Â±è (Fullscreen)</button>
                <div class="checkbox-container">
                    <input type="checkbox" id="randomCheckbox">
                    <label for="randomCheckbox">ÈöèÊú∫È°∫Â∫è (Random Order)</label>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const characters = [ /* ... (character list remains the same) ... */
             // Numbers & Basics
            { char: '‰∏Ä', pinyin: 'yƒ´', meaning: 'one', emoji: '1Ô∏è‚É£' }, { char: '‰∫å', pinyin: '√®r', meaning: 'two', emoji: '2Ô∏è‚É£' }, { char: '‰∏â', pinyin: 'sƒÅn', meaning: 'three', emoji: '3Ô∏è‚É£' }, { char: 'Âõõ', pinyin: 's√¨', meaning: 'four', emoji: '4Ô∏è‚É£' }, { char: '‰∫î', pinyin: 'w«î', meaning: 'five', emoji: '5Ô∏è‚É£' }, { char: 'ÂÖ≠', pinyin: 'li√π', meaning: 'six', emoji: '6Ô∏è‚É£' }, { char: '‰∏É', pinyin: 'qƒ´', meaning: 'seven', emoji: '7Ô∏è‚É£' }, { char: 'ÂÖ´', pinyin: 'bƒÅ', meaning: 'eight', emoji: '8Ô∏è‚É£' }, { char: '‰πù', pinyin: 'ji«î', meaning: 'nine', emoji: '9Ô∏è‚É£' }, { char: 'ÂçÅ', pinyin: 'sh√≠', meaning: 'ten', emoji: 'üîü' }, { char: 'Áôæ', pinyin: 'b«éi', meaning: 'hundred', emoji: 'üíØ' }, { char: '‰∫∫', pinyin: 'r√©n', meaning: 'person', emoji: 'üë§' }, { char: 'Â§ß', pinyin: 'd√†', meaning: 'big', emoji: 'üêò' }, { char: 'Â∞è', pinyin: 'xi«éo', meaning: 'small', emoji: 'üêú' }, { char: 'Âè£', pinyin: 'k«íu', meaning: 'mouth', emoji: 'üëÑ' }, { char: '‰∏≠', pinyin: 'zh≈çng', meaning: 'middle', emoji: 'üéØ' }, { char: 'ÂõΩ', pinyin: 'gu√≥', meaning: 'country', emoji: 'üó∫Ô∏è' },
            // Nature
            { char: 'Êó•', pinyin: 'r√¨', meaning: 'sun', emoji: '‚òÄÔ∏è' }, { char: 'Êúà', pinyin: 'yu√®', meaning: 'moon', emoji: 'üåô' }, { char: 'Êú®', pinyin: 'm√π', meaning: 'wood', emoji: 'üå≥' }, { char: 'Ê∞¥', pinyin: 'shu«ê', meaning: 'water', emoji: 'üíß' }, { char: 'ÁÅ´', pinyin: 'hu«í', meaning: 'fire', emoji: 'üî•' }, { char: 'Â±±', pinyin: 'shƒÅn', meaning: 'mountain', emoji: '‚õ∞Ô∏è' }, { char: 'Áî∞', pinyin: 'ti√°n', meaning: 'field', emoji: 'üèûÔ∏è' }, { char: 'Âúü', pinyin: 't«î', meaning: 'earth', emoji: 'üß±' }, { char: 'Â§©', pinyin: 'tiƒÅn', meaning: 'sky / day', emoji: '‚òÅÔ∏è' }, { char: '‰∫ë', pinyin: 'y√∫n', meaning: 'cloud', emoji: '‚òÅÔ∏è' }, { char: 'Èõ®', pinyin: 'y«î', meaning: 'rain', emoji: 'üåßÔ∏è' }, { char: 'Ëä±', pinyin: 'huƒÅ', meaning: 'flower', emoji: 'üå∏' }, { char: 'Ëçâ', pinyin: 'c«éo', meaning: 'grass', emoji: 'üåø' }, { char: 'È£é', pinyin: 'fƒìng', meaning: 'wind', emoji: 'üå¨Ô∏è' }, { char: 'Áü≥', pinyin: 'sh√≠', meaning: 'stone', emoji: 'ü™®' },
            // Animals
            { char: 'Áâõ', pinyin: 'ni√∫', meaning: 'cow', emoji: 'üêÆ' }, { char: 'Áæä', pinyin: 'y√°ng', meaning: 'sheep', emoji: 'üêë' }, { char: 'È©¨', pinyin: 'm«é', meaning: 'horse', emoji: 'üê¥' }, { char: 'È±º', pinyin: 'y√∫', meaning: 'fish', emoji: 'üê†' }, { char: 'È∏ü', pinyin: 'ni«éo', meaning: 'bird', emoji: 'üê¶' }, { char: 'Ëô´', pinyin: 'ch√≥ng', meaning: 'insect', emoji: 'üêõ' }, { char: 'Áãó', pinyin: 'g«íu', meaning: 'dog', emoji: 'üê∂' }, { char: 'Áå´', pinyin: 'mƒÅo', meaning: 'cat', emoji: 'üê±' }, { char: 'ÂÖî', pinyin: 't√π', meaning: 'rabbit', emoji: 'üê∞' },
            // Family & People
            { char: 'Áà∏', pinyin: 'b√†', meaning: 'dad', emoji: 'üë®' }, { char: 'Â¶à', pinyin: 'mƒÅ', meaning: 'mom', emoji: 'üë©' }, { char: 'Êàë', pinyin: 'w«í', meaning: 'I / me', emoji: 'üôã' }, { char: '‰Ω†', pinyin: 'n«ê', meaning: 'you', emoji: 'üëâ' }, { char: '‰ªñ', pinyin: 'tƒÅ', meaning: 'he / him', emoji: 'üßç‚Äç‚ôÇÔ∏è' }, { char: 'Â•π', pinyin: 'tƒÅ', meaning: 'she / her', emoji: 'üßç‚Äç‚ôÄÔ∏è' }, { char: 'ÂÆ∂', pinyin: 'jiƒÅ', meaning: 'home / family', emoji: 'üè†' }, { char: 'Â≠ê', pinyin: 'z«ê', meaning: 'child / son', emoji: 'üë∂' }, { char: 'Â•≥', pinyin: 'n«ö', meaning: 'female / woman', emoji: '‚ôÄÔ∏è' }, { char: 'Áî∑', pinyin: 'n√°n', meaning: 'male / man', emoji: '‚ôÇÔ∏è' }, { char: 'Âèã', pinyin: 'y«íu', meaning: 'friend', emoji: 'üßë‚Äçü§ù‚Äçüßë' }, { char: 'Áîü', pinyin: 'shƒìng', meaning: 'birth / life', emoji: 'üå±' },
            // Actions & Verbs
            { char: 'Áà±', pinyin: '√†i', meaning: 'love', emoji: '‚ù§Ô∏è' }, { char: 'Áúã', pinyin: 'k√†n', meaning: 'look / see', emoji: 'üëÄ' }, { char: 'ÂêÉ', pinyin: 'chƒ´', meaning: 'eat', emoji: 'üçé' }, { char: 'Âñù', pinyin: 'hƒì', meaning: 'drink', emoji: 'ü•§' }, { char: 'Âéª', pinyin: 'q√π', meaning: 'go', emoji: '‚û°Ô∏è' }, { char: 'Êù•', pinyin: 'l√°i', meaning: 'come', emoji: '‚¨ÖÔ∏è' }, { char: 'Ëµ∞', pinyin: 'z«íu', meaning: 'walk', emoji: 'üö∂' }, { char: 'Âùê', pinyin: 'zu√≤', meaning: 'sit', emoji: 'üßò' }, { char: 'ËØ¥', pinyin: 'shu≈ç', meaning: 'speak / say', emoji: 'üó£Ô∏è' }, { char: 'Á¨ë', pinyin: 'xi√†o', meaning: 'laugh / smile', emoji: 'üòä' }, { char: 'Âì≠', pinyin: 'k≈´', meaning: 'cry', emoji: 'üò¢' }, { char: 'Êúâ', pinyin: 'y«íu', meaning: 'have / there is', emoji: '‚úÖ' }, { char: 'Êó†', pinyin: 'w√∫', meaning: 'not have / without', emoji: '‚ùå' }, { char: 'ÊòØ', pinyin: 'sh√¨', meaning: 'to be (is, am, are)', emoji: '‚úîÔ∏è' }, { char: 'Âú®', pinyin: 'z√†i', meaning: 'at / in / on', emoji: 'üìç' }, { char: 'Â≠¶', pinyin: 'xu√©', meaning: 'learn / study', emoji: 'üìö' }, { char: 'ÂÜô', pinyin: 'xiƒõ', meaning: 'write', emoji: '‚úçÔ∏è' }, { char: 'Áîª', pinyin: 'hu√†', meaning: 'draw / picture', emoji: 'üé®' }, { char: 'Áé©', pinyin: 'w√°n', meaning: 'play', emoji: '‚öΩ' },
            // Objects & Things
            { char: 'ËΩ¶', pinyin: 'chƒì', meaning: 'car / vehicle', emoji: 'üöó' }, { char: 'Èó®', pinyin: 'm√©n', meaning: 'door', emoji: 'üö™' }, { char: '‰π¶', pinyin: 'sh≈´', meaning: 'book', emoji: 'üìñ' }, { char: 'Á¨î', pinyin: 'b«ê', meaning: 'pen', emoji: 'üñäÔ∏è' }, { char: 'ÂàÄ', pinyin: 'dƒÅo', meaning: 'knife', emoji: 'üî™' }, { char: 'Êâã', pinyin: 'sh«íu', meaning: 'hand', emoji: 'üñêÔ∏è' }, { char: 'Ë∂≥', pinyin: 'z√∫', meaning: 'foot', emoji: 'ü¶∂' }, { char: 'Â§¥', pinyin: 't√≥u', meaning: 'head', emoji: 'üë§' }, { char: 'ÂøÉ', pinyin: 'xƒ´n', meaning: 'heart', emoji: '‚ù§Ô∏è' }, { char: 'Ë°£', pinyin: 'yƒ´', meaning: 'clothes', emoji: 'üëï' }, { char: 'Á±≥', pinyin: 'm«ê', meaning: 'rice', emoji: 'üçö' }, { char: 'Áìú', pinyin: 'guƒÅ', meaning: 'melon', emoji: 'üçâ' },
            // Directions & Position
            { char: '‰∏ä', pinyin: 'sh√†ng', meaning: 'up / on', emoji: '‚¨ÜÔ∏è' }, { char: '‰∏ã', pinyin: 'xi√†', meaning: 'down / under', emoji: '‚¨áÔ∏è' }, { char: 'Â∑¶', pinyin: 'zu«í', meaning: 'left', emoji: '‚¨ÖÔ∏è' }, { char: 'Âè≥', pinyin: 'y√≤u', meaning: 'right', emoji: '‚û°Ô∏è' }, { char: 'Ââç', pinyin: 'qi√°n', meaning: 'front / before', emoji: 'üîº' }, { char: 'Âêé', pinyin: 'h√≤u', meaning: 'back / after', emoji: 'üîΩ' }, { char: '‰∏ú', pinyin: 'd≈çng', meaning: 'east', emoji: 'üá™' }, { char: 'Ë•ø', pinyin: 'xƒ´', meaning: 'west', emoji: 'üáº' }, { char: 'Âçó', pinyin: 'n√°n', meaning: 'south', emoji: 'üá∏' }, { char: 'Âåó', pinyin: 'bƒõi', meaning: 'north', emoji: 'üá≥' },
            // Adjectives & Others
            { char: 'Â•Ω', pinyin: 'h«éo', meaning: 'good / well', emoji: 'üëç' }, { char: '‰∏ç', pinyin: 'b√π', meaning: 'not / no', emoji: 'üö´' }, { char: 'Â§ö', pinyin: 'du≈ç', meaning: 'many / much', emoji: '‚ûï' }, { char: 'Â∞ë', pinyin: 'sh«éo', meaning: 'few / little', emoji: '‚ûñ' }, { char: 'È´ò', pinyin: 'gƒÅo', meaning: 'high / tall', emoji: 'ü¶í' }, { char: 'Èïø', pinyin: 'ch√°ng', meaning: 'long', emoji: 'üìè' }, { char: 'Á∫¢', pinyin: 'h√≥ng', meaning: 'red', emoji: 'üü•' }, { char: 'ÁôΩ', pinyin: 'b√°i', meaning: 'white', emoji: '‚¨ú' }, { char: 'Èªë', pinyin: 'hƒìi', meaning: 'black', emoji: '‚¨õ' }, { char: 'ÈªÑ', pinyin: 'hu√°ng', meaning: 'yellow', emoji: 'üü®' }, { char: 'Áªø', pinyin: 'l«ú', meaning: 'green', emoji: 'üü©' }, { char: 'Ëìù', pinyin: 'l√°n', meaning: 'blue', emoji: 'üü¶' }, { char: 'ÂºÄ', pinyin: 'kƒÅi', meaning: 'open / start', emoji: 'üîì' }, { char: 'ÂÖ≥', pinyin: 'guƒÅn', meaning: 'close / turn off', emoji: 'üîí' },
        ];
        let currentCharacterIndex = 0;
        const drawingColor = "#000000";
        const drawingLineWidth = 18;

        // --- Canvas and Context ---
        const canvasContainer = document.getElementById('canvasContainer');
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // --- DOM Elements ---
        const tocListContainer = document.getElementById('tocList');
        const characterDisplay = document.getElementById('characterDisplay');
        const meaningEmoji = document.getElementById('meaningEmoji');
        const clearBtn = document.getElementById('clearBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const randomCheckbox = document.getElementById('randomCheckbox');

        // --- Speech Synthesis ---
        const synth = window.speechSynthesis;
        let voices = [];
        function populateVoiceList() { /* ... (no changes) ... */
            if(typeof speechSynthesis === 'undefined') { console.warn("ËØ≠Èü≥ÂêàÊàê‰∏çÊîØÊåÅ (Speech Synthesis not supported)."); return; }
            voices = synth.getVoices().filter(voice => voice.lang.startsWith('zh'));
            if (voices.length === 0 && synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = () => { voices = synth.getVoices().filter(voice => voice.lang.startsWith('zh')); console.log("ËØ≠Èü≥Â∫ìÂ∑≤Âä†ËΩΩ (Voices loaded):", voices); };
            } else { console.log("ÊâæÂà∞‰∏≠ÊñáËØ≠Èü≥Â∫ì (Chinese voices found):", voices); }
        }
        populateVoiceList();
        if (typeof speechSynthesis !== 'undefined' && speechSynthesis.onvoiceschanged !== undefined) { speechSynthesis.onvoiceschanged = populateVoiceList; }
        function speakCharacter(character) { /* ... (no changes) ... */
            if (!synth) return; if (synth.speaking) synth.cancel();
            if (character !== '') {
                const utterThis = new SpeechSynthesisUtterance(character);
                utterThis.onerror = (event) => console.error('ËØ≠Èü≥ÂêàÊàêÈîôËØØ (SpeechSynthesisUtterance.onerror)', event);
                const chineseVoice = voices.find(voice => voice.lang === 'zh-CN') || voices.find(voice => voice.lang.startsWith('zh'));
                if (chineseVoice) utterThis.voice = chineseVoice; else utterThis.lang = 'zh-CN';
                utterThis.pitch = 1; utterThis.rate = 0.8;
                setTimeout(() => synth.speak(utterThis), 50);
            }
        }

        // --- Functions ---

        function populateTOC() { /* ... (no changes) ... */
            tocListContainer.innerHTML = ''; characters.forEach((charData, index) => {
                const tocItem = document.createElement('div'); tocItem.classList.add('toc-item');
                tocItem.textContent = charData.char; tocItem.dataset.index = index;
                tocListContainer.appendChild(tocItem);
            });
        }
        function updateTocHighlight() { /* ... (no changes) ... */
            const previousActive = tocListContainer.querySelector('.toc-item.active'); if (previousActive) previousActive.classList.remove('active');
            const currentActive = tocListContainer.querySelector(`.toc-item[data-index="${currentCharacterIndex}"]`);
            if (currentActive) { currentActive.classList.add('active'); currentActive.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
        }
        function resizeCanvas() { /* ... (no changes) ... */
            const containerRect = canvasContainer.getBoundingClientRect(); canvas.width = containerRect.width; canvas.height = containerRect.height;
            ctx.strokeStyle = drawingColor; ctx.lineWidth = drawingLineWidth; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            if (characters.length > 0) { displayCharacter(); }
        }
        function displayCharacter() { /* ... (no changes) ... */
            if (currentCharacterIndex < 0 || currentCharacterIndex >= characters.length) { console.error("Êó†ÊïàÁ¥¢Âºï (Invalid index):", currentCharacterIndex); currentCharacterIndex = 0; if (characters.length === 0) return; }
            const currentCharData = characters[currentCharacterIndex]; characterDisplay.textContent = currentCharData.char;
            meaningEmoji.textContent = currentCharData.emoji || ''; clearCanvas(); speakCharacter(currentCharData.char); updateTocHighlight();
        }
        function clearCanvas() { /* ... (no changes) ... */ ctx.clearRect(0, 0, canvas.width, canvas.height); }
        function startDrawing(e) { /* ... (no changes) ... */ isDrawing = true; const pos = getMousePos(canvas, e); if (!pos) return; [lastX, lastY] = [pos.x, pos.y]; ctx.beginPath(); ctx.moveTo(lastX, lastY); e.preventDefault(); }
        function draw(e) { /* ... (no changes) ... */ if (!isDrawing) return; const pos = getMousePos(canvas, e); if (!pos) return; ctx.lineTo(pos.x, pos.y); ctx.stroke(); [lastX, lastY] = [pos.x, pos.y]; e.preventDefault(); }
        function stopDrawing(e) { /* ... (no changes) ... */ if (isDrawing) isDrawing = false; e.preventDefault(); }
        function getMousePos(canvasDom, event) { /* ... (no changes) ... */
            const rect = canvasDom.getBoundingClientRect(); let clientX, clientY;
            if (event.touches && event.touches.length > 0) { clientX = event.touches[0].clientX; clientY = event.touches[0].clientY; }
            else if (event.changedTouches && event.changedTouches.length > 0) { clientX = event.changedTouches[0].clientX; clientY = event.changedTouches[0].clientY; }
            else if (event.clientX !== undefined) { clientX = event.clientX; clientY = event.clientY; } else { return null; }
            return { x: clientX - rect.left, y: clientY - rect.top };
        }
        function previousCharacter() { /* ... (no changes) ... */
            if (characters.length === 0 || randomCheckbox.checked) return;
            currentCharacterIndex = (currentCharacterIndex - 1 + characters.length) % characters.length; displayCharacter();
        }
        function nextCharacter() { /* ... (no changes) ... */
            if (characters.length === 0) return; const isRandom = randomCheckbox.checked; let nextIndex;
            if (isRandom) { if (characters.length <= 1) nextIndex = 0; else do { nextIndex = Math.floor(Math.random() * characters.length); } while (nextIndex === currentCharacterIndex); }
            else { nextIndex = (currentCharacterIndex + 1) % characters.length; }
            currentCharacterIndex = nextIndex; displayCharacter();
        }
        function handleTocClick(event) { /* ... (no changes) ... */
            const target = event.target; if (target.classList.contains('toc-item') && target.dataset.index !== undefined) {
                const index = parseInt(target.dataset.index, 10); if (!isNaN(index) && index >= 0 && index < characters.length) { currentCharacterIndex = index; displayCharacter(); }
            }
        }

        // Function to request fullscreen mode - **MODIFIED**
        function enterFullscreen() {
            // ËØ∑Ê±ÇÊï¥‰∏™ÊñáÊ°£ËøõÂÖ•ÂÖ®Â±èÔºåËÄå‰∏çÊòØ‰ªÖ‰ªÖÊòØ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü
            // Request fullscreen on the entire document element
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(err => console.error(`ÂÖ®Â±èÊ®°ÂºèÈîôËØØ (Fullscreen error): ${err.message} (${err.name})`));
            } else if (elem.webkitRequestFullscreen) { /* Safari */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE11 */
                elem.msRequestFullscreen();
            }
            // Also added a background color to #mainContentArea in CSS as a fallback
        }

        function togglePrevButton() { /* ... (no changes) ... */ prevBtn.disabled = randomCheckbox.checked; }

        // --- Event Listeners --- /* ... (no changes) ... */
        canvas.addEventListener('mousedown', startDrawing); canvas.addEventListener('mousemove', draw); canvas.addEventListener('mouseup', stopDrawing); canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchstart', startDrawing, { passive: false }); canvas.addEventListener('touchmove', draw, { passive: false }); canvas.addEventListener('touchend', stopDrawing, { passive: false }); canvas.addEventListener('touchcancel', stopDrawing, { passive: false });
        clearBtn.addEventListener('click', clearCanvas); prevBtn.addEventListener('click', previousCharacter); nextBtn.addEventListener('click', nextCharacter); fullscreenBtn.addEventListener('click', enterFullscreen);
        tocListContainer.addEventListener('click', handleTocClick); randomCheckbox.addEventListener('change', togglePrevButton);
        window.addEventListener('resize', resizeCanvas);

        // --- Initialization ---
        populateTOC();
        resizeCanvas(); // Calls displayCharacter
        togglePrevButton(); // Set initial state of Prev button

        // --- Safety Note ---
        console.log("ÊèêÁ§∫Ôºö‰∏∫‰∫ÜÂú®iPad‰∏äËé∑ÂæóÊúÄ‰Ω≥ÁöÑ‚ÄúÈîÅÂÆö‚Äù‰ΩìÈ™åÔºåËØ∑Âú® ËÆæÁΩÆ > ËæÖÂä©ÂäüËÉΩ ‰∏≠‰ΩøÁî®‚ÄúÂºïÂØºÂºèËÆøÈóÆ‚ÄùÂäüËÉΩ„ÄÇ(Tip: For the best 'locked-in' experience on iPad, use 'Guided Access' in Settings > Accessibility.)");

    </script>
</body>
</html>
